/**
 * ColorBends Background Effect
 * Adapted from React implementation to Vanilla JS with Three.js
 */

const MAX_COLORS = 8;

const frag = `
#define MAX_COLORS ${MAX_COLORS}
uniform vec2 uCanvas;
uniform float uTime;
uniform float uSpeed;
uniform vec2 uRot;
uniform int uColorCount;
uniform vec3 uColors[MAX_COLORS];
uniform int uTransparent;
uniform float uScale;
uniform float uFrequency;
uniform float uWarpStrength;
uniform vec2 uPointer; // in NDC [-1,1]
uniform float uMouseInfluence;
uniform float uParallax;
uniform float uNoise;
varying vec2 vUv;

void main() {
  float t = uTime * uSpeed;
  vec2 p = vUv * 2.0 - 1.0;
  p += uPointer * uParallax * 0.1;
  vec2 rp = vec2(p.x * uRot.x - p.y * uRot.y, p.x * uRot.y + p.y * uRot.x);
  vec2 q = vec2(rp.x * (uCanvas.x / uCanvas.y), rp.y);
  q /= max(uScale, 0.0001);
  q /= 0.5 + 0.2 * dot(q, q);
  q += 0.2 * cos(t) - 7.56;
  vec2 toward = (uPointer - rp);
  q += toward * uMouseInfluence * 0.2;

    vec3 col = vec3(0.0);
    float a = 1.0;

    if (uColorCount > 0) {
      vec2 s = q;
      vec3 sumCol = vec3(0.0);
      float cover = 0.0;
      for (int i = 0; i < MAX_COLORS; ++i) {
            if (i >= uColorCount) break;
            s -= 0.01;
            vec2 r = sin(1.5 * (s.yx * uFrequency) + 2.0 * cos(s * uFrequency));
            float m0 = length(r + sin(5.0 * r.y * uFrequency - 3.0 * t + float(i)) / 4.0);
            float kBelow = clamp(uWarpStrength, 0.0, 1.0);
            float kMix = pow(kBelow, 0.3);
            float gain = 1.0 + max(uWarpStrength - 1.0, 0.0); // allow >1 to amplify displacement
            vec2 disp = (r - s) * kBelow;
            vec2 warped = s + disp * gain;
            float m1 = length(warped + sin(5.0 * warped.y * uFrequency - 3.0 * t + float(i)) / 4.0);
            float m = mix(m0, m1, kMix);
            float w = 1.0 - exp(-6.0 / exp(6.0 * m));
            sumCol += uColors[i] * w;
            cover = max(cover, w);
      }
      col = clamp(sumCol, 0.0, 1.0);
      a = uTransparent > 0 ? cover : 1.0;
    } else {
        vec2 s = q;
        for (int k = 0; k < 3; ++k) {
            s -= 0.01;
            vec2 r = sin(1.5 * (s.yx * uFrequency) + 2.0 * cos(s * uFrequency));
            float m0 = length(r + sin(5.0 * r.y * uFrequency - 3.0 * t + float(k)) / 4.0);
            float kBelow = clamp(uWarpStrength, 0.0, 1.0);
            float kMix = pow(kBelow, 0.3);
            float gain = 1.0 + max(uWarpStrength - 1.0, 0.0);
            vec2 disp = (r - s) * kBelow;
            vec2 warped = s + disp * gain;
            float m1 = length(warped + sin(5.0 * warped.y * uFrequency - 3.0 * t + float(k)) / 4.0);
            float m = mix(m0, m1, kMix);
            col[k] = 1.0 - exp(-6.0 / exp(6.0 * m));
        }
        a = uTransparent > 0 ? max(max(col.r, col.g), col.b) : 1.0;
    }

    if (uNoise > 0.0001) {
      float n = fract(sin(dot(gl_FragCoord.xy + vec2(uTime), vec2(12.9898, 78.233))) * 43758.5453123);
      col += (n - 0.5) * uNoise;
      col = clamp(col, 0.0, 1.0);
    }

    vec3 rgb = (uTransparent > 0) ? col * a : col;
    gl_FragColor = vec4(rgb, a);
}
`;

const vert = `
varying vec2 vUv;
void main() {
  vUv = uv;
  gl_Position = vec4(position, 1.0);
}
`;

class ColorBends {
    constructor(containerId, options = {}) {
        this.container = document.getElementById(containerId);
        if (!this.container) {
            console.error(`Container with id '${containerId}' not found.`);
            return;
        }

        this.options = Object.assign({
            rotation: 0,
            speed: 0.2,
            colors: ["#ff5c7a", "#8a5cff", "#00ffd1"],
            transparent: true,
            autoRotate: 0,
            scale: 1,
            frequency: 1,
            warpStrength: 1,
            mouseInfluence: 1,
            parallax: 0.5,
            noise: 0.1
        }, options);

        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.material = null;
        this.mesh = null;
        this.clock = new THREE.Clock();
        this.rafId = null;

        this.pointerTarget = new THREE.Vector2(0, 0);
        this.pointerCurrent = new THREE.Vector2(0, 0);
        this.pointerSmooth = 8;

        this.boundAnimate = this.animate.bind(this);
        this.boundResize = this.handleResize.bind(this);
        this.boundMouseMove = this.handleMouseMove.bind(this);

        this.init();
        this.addEventListeners();
        this.animate();
    }

    init() {
        this.scene = new THREE.Scene();
        this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

        const geometry = new THREE.PlaneGeometry(2, 2);

        // Prepare uniforms
        const uColorsArray = Array.from({ length: MAX_COLORS }, () => new THREE.Vector3(0, 0, 0));
        const toVec3 = hex => {
            const h = hex.replace('#', '').trim();
            const v = h.length === 3
                ? [parseInt(h[0] + h[0], 16), parseInt(h[1] + h[1], 16), parseInt(h[2] + h[2], 16)]
                : [parseInt(h.slice(0, 2), 16), parseInt(h.slice(2, 4), 16), parseInt(h.slice(4, 6), 16)];
            return new THREE.Vector3(v[0] / 255, v[1] / 255, v[2] / 255);
        };

        const arr = (this.options.colors || []).filter(Boolean).slice(0, MAX_COLORS).map(toVec3);
        arr.forEach((vec, i) => uColorsArray[i].copy(vec));

        this.material = new THREE.ShaderMaterial({
            vertexShader: vert,
            fragmentShader: frag,
            uniforms: {
                uCanvas: { value: new THREE.Vector2(1, 1) },
                uTime: { value: 0 },
                uSpeed: { value: this.options.speed },
                uRot: { value: new THREE.Vector2(1, 0) },
                uColorCount: { value: arr.length },
                uColors: { value: uColorsArray },
                uTransparent: { value: this.options.transparent ? 1 : 0 },
                uScale: { value: this.options.scale },
                uFrequency: { value: this.options.frequency },
                uWarpStrength: { value: this.options.warpStrength },
                uPointer: { value: new THREE.Vector2(0, 0) },
                uMouseInfluence: { value: this.options.mouseInfluence },
                uParallax: { value: this.options.parallax },
                uNoise: { value: this.options.noise }
            },
            transparent: true
        });

        this.mesh = new THREE.Mesh(geometry, this.material);
        this.scene.add(this.mesh);

        this.renderer = new THREE.WebGLRenderer({
            antialias: false,
            powerPreference: 'high-performance',
            alpha: true
        });

        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
        this.renderer.setClearColor(0x000000, 0); // Always clear with alpha 0 as we use Shader transparency

        // Ensure container has no overflow
        this.container.style.overflow = 'hidden';
        this.container.appendChild(this.renderer.domElement);

        this.handleResize();
    }

    handleResize() {
        if (!this.container || !this.renderer) return;
        const w = this.container.clientWidth;
        const h = this.container.clientHeight;
        this.renderer.setSize(w, h, false);
        this.material.uniforms.uCanvas.value.set(w, h);
    }

    handleMouseMove(e) {
        const rect = this.container.getBoundingClientRect();
        const x = ((e.clientX - rect.left) / (rect.width || 1)) * 2 - 1;
        const y = -(((e.clientY - rect.top) / (rect.height || 1)) * 2 - 1);
        this.pointerTarget.set(x, y);
    }

    addEventListeners() {
        window.addEventListener('resize', this.boundResize);
        document.addEventListener('pointermove', this.boundMouseMove);
    }

    animate() {
        if (!this.scene) return;

        this.rafId = requestAnimationFrame(this.boundAnimate);

        const dt = this.clock.getDelta();
        const elapsed = this.clock.elapsedTime;
        this.material.uniforms.uTime.value = elapsed;

        const deg = (this.options.rotation % 360) + (this.options.autoRotate * elapsed);
        const rad = (deg * Math.PI) / 180;
        this.material.uniforms.uRot.value.set(Math.cos(rad), Math.sin(rad));

        const cur = this.pointerCurrent;
        const tgt = this.pointerTarget;
        const amt = Math.min(1, dt * this.pointerSmooth);
        cur.lerp(tgt, amt);
        this.material.uniforms.uPointer.value.copy(cur);

        this.renderer.render(this.scene, this.camera);
    }

    dispose() {
        cancelAnimationFrame(this.rafId);
        window.removeEventListener('resize', this.boundResize);
        document.removeEventListener('pointermove', this.boundMouseMove);

        if (this.renderer) {
            this.renderer.dispose();
            this.container.removeChild(this.renderer.domElement);
        }
        if (this.material) this.material.dispose();
        if (this.geometry) this.geometry.dispose();
    }
}
